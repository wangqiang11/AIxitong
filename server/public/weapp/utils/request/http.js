"use strict";var e=Object.defineProperty,t=(t,s,r)=>(((t,s,r)=>{s in t?e(t,s,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[s]=r})(t,"symbol"!=typeof s?s+"":s,r),r);const s=require("../../common/vendor.js"),r=require("../../enums/requestEnums.js"),o=require("./cancel.js");exports.HttpRequest=class{constructor(e){t(this,"options"),this.options=e}retryRequest(e,t){var o;const{retryCount:n,retryTimeout:u}=t;return n&&(null==(o=e.method)?void 0:o.toUpperCase())!=r.RequestMethodsEnum.POST?(s.index.showLoading({title:"加载中..."}),t.hasRetryCount=t.hasRetryCount||0,t.hasRetryCount>=n?Promise.reject():(t.hasRetryCount++,t.requestHooks.requestInterceptorsHook=e=>e,new Promise((e=>setTimeout(e,u))).then((()=>this.request(e,t))).finally((()=>s.index.hideLoading())))):Promise.reject()}get(e,t){return this.request({...e,method:r.RequestMethodsEnum.GET},t)}post(e,t){return this.request({...e,method:r.RequestMethodsEnum.POST},t)}eventStream(e,t){let r=s.merge({},this.options.requestOptions,e);const o=s.merge({},this.options,t),{requestInterceptorsHook:n,responseInterceptorsHook:u}=o.requestHooks||{};n&&s.isFunction(n)&&(r=n(r,o));const{onmessage:i,onclose:c,onstart:a}=o;return new Promise(((e,t)=>{try{let n={};const l=s.index.request({...r,enableChunked:!0,responseType:"arraybuffer",async success(s){200===s.statusCode?e(s):t(s)},fail(e){t(e)},complete(){null==c||c()}});null==a||a(l),l.onHeadersReceived((e=>{n=e.header})),l.onChunkReceived((async c=>{const a=c.data,l=function(e){let t="";for(let s=0;s<e.length;s++)t+=String.fromCharCode(e[s]);return decodeURIComponent(escape(t))}(new Uint8Array(a));if(function(e){const t=(null==e?void 0:e["Content-Type"])||(null==e?void 0:e["content-type"])||e.get("content-type");return"string"==typeof t&&t.includes("text/event-stream")}(n))console.log((new Date).getTime(),l),null==i||i(l);else{const n=s.parse(l);if(u&&s.isFunction(u)){try{const t=await u({data:n,statusCode:200},o,r);e(t)}catch(p){t(p)}return}}}))}catch(n){t()}}))}uploadFile(e,t){let o=s.merge({},this.options.requestOptions,e);const n=s.merge({},this.options,t),{requestInterceptorsHook:u,responseInterceptorsHook:i,responseInterceptorsCatchHook:c}=n.requestHooks||{};return u&&s.isFunction(u)&&(o=u(o,n)),new Promise(((e,t)=>{s.index.uploadFile({...o,header:{...o.header},async success(r){if(200==r.statusCode){if(r.data=JSON.parse(r.data),i&&s.isFunction(i)){try{r=await i(r,n,o),e(r)}catch(u){t(u)}return}e(r)}else t(r.errMsg)},fail(e){e.errMsg!=r.RequestErrMsgEnum.ABORT&&(c&&s.isFunction(c)?t(c(o,e)):t(e.errMsg||e))}}).onProgressUpdate((({progress:e})=>{var t;null==(t=n.onProgress)||t.call(n,e)}))}))}async request(e,t){let n=s.merge({},this.options.requestOptions,e);const u=s.merge({},this.options,t),{requestInterceptorsHook:i,responseInterceptorsHook:c,responseInterceptorsCatchHook:a}=u.requestHooks||{};return i&&s.isFunction(i)&&(n=i(n,u)),new Promise(((t,i)=>{const l=s.index.request({...n,async success(e){if(200!==e.statusCode)return i();if(c&&s.isFunction(c))try{e=await c(e,u,n),t(e)}catch(r){i(r)}else t(e)},fail:async e=>{e.errMsg!=r.RequestErrMsgEnum.TIMEOUT?e.errMsg!=r.RequestErrMsgEnum.ABORT&&(a&&s.isFunction(a)?i(await a(n,e)):i(e)):this.retryRequest(n,u).then((e=>t(e))).catch((e=>i(e)))},complete(t){t.errMsg!==r.RequestErrMsgEnum.ABORT&&o.requestCancel.remove(e.url)}}),{ignoreCancel:p}=u;!p&&o.requestCancel.add(e.url,l)}))}};
